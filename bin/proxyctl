#!/usr/bin/env bash

# Start containers for a project identified with a virtual host
# @param $1 virtual host name
_start ()
{
	local vhost="$1"
	[[ "$vhost" == "" ]] &&  echo "ERROR: Empty virtual host." && return 1
	
	# Match vhost to a running web (exact match only)
	local project_name
	project_name=$(/usr/local/bin/docker ps -a \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host=$vhost" \
		--format '{{.Label "com.docker.compose.project"}}')
	
	# If exact match was not found, then we have multiple domains/wildcards (e.g. example.com,*.example.com,example2.com)
	# Complex processing goes below.
	if [[ "$project_name" == "" ]]; then
		# Get a list of all (running and stopped) web containers and their virtual host label values
		local webs=$(/usr/local/bin/docker ps -a \
		--filter "label=com.docker.compose.service=web" \
		--format '{{.Label "com.docker.compose.project"}}:{{.Label "io.docksal.virtual-host"}}')
		
		# Look for a matching label among all webs
		for web in $webs; do
			# Read variables
			IFS=':' read web_project_name web_project_vhost <<< "$web";
			# Split web_project_vhost
			IFS=',' read -a web_project_vhost_arr <<< "$web_project_vhost"
			for i in "${web_project_vhost_arr[@]}"; do
				# Turn domain name into a regular expression (e.g. *.example.com => .*\.example\.com)
				i_reg=$(echo $i | sed "s/\./\\\\./g" | sed "s/\*/\.\*/g")
				# Match vhost using the regular expression we created
				echo "$vhost" | grep "^$i_reg$" >/dev/null
				# Store match and break
				[[ $? -eq 0 ]] && project_name="$web_project_name" && break
			done
			# Break if match was found
			[[ "$project_name" != "" ]] && break
		done
	fi

	# No match if project_name is empty here.
	[[ "$project_name" == "" ]] && echo "ERROR: No matching projects found for virtual host ${vhost}." && return 1

	echo "Starting containers for $project_name..."
	# Dirty hack to avoid using docker-compose and still be able to launch containers with dependencies up to 3 levels deep.
	for i in `seq 1 3`; do
		echo "Pass #$i..."
		/usr/local/bin/docker ps -qa --filter "label=com.docker.compose.project=${project_name}" | xargs /usr/local/bin/docker start
	done

    # Reconnect vhost-proxy to the project network (in case vhost-proxy has been recently reset)
    local network="${project_name}_default"
    /usr/local/bin/docker network connect "$network" vhost-proxy >/dev/null 2>&1
    if [[ $? == 0 ]]; then
      echo "Connected proxy to network: ${network}."
    fi
    # Trigger docker-gen with a dummy container to refresh nginx configuration.
    # This covers a case when containers are already running, but proxy was just created and connected to project networks.
    echo "Triggering docker-gen..."
    /usr/local/bin/docker run --rm busybox
}

# Stop containers for inactive projects
_stop ()
{
	INACTIVITY_TIMEOUT="${INACTIVITY_TIMEOUT:-30m}"
	
	# Get a list of running web containers
	local running_webs=$(/usr/local/bin/docker ps \
		--filter "label=com.docker.compose.service=web" \
		--format '{{.ID}}:{{.Label "com.docker.compose.project"}}')
	
	for running_web in $running_webs; do
		# Read variables
		IFS=':' read container_id project_name <<< "$running_web";
		# Skip containers with empty values
		[[ "$project_name" == "" ]] && continue
		
		# See if there was any recent container activity (entries in container logs)
		if [[ "$(/usr/local/bin/docker logs --tail 1 --since $INACTIVITY_TIMEOUT $container_id)" != "" ]]; then
			# Active
			echo "Project: $project_name is active. Skipping."
		else
			# Not active
			echo "Project: $project_name is NOT active. Stopping..."
			# Stop
			/usr/local/bin/docker ps -q --filter "label=com.docker.compose.project=${project_name}" | xargs /usr/local/bin/docker stop
		fi
	done
}

_cron ()
{
	_stop
}

# Trigger nginx config reload
_notify ()
{
	if [[ "$PROXY_DEBUG" == 1 ]]; then
		cat /etc/nginx/conf.d/default.conf
	fi
	nginx -t && nginx -s reload
}

#-------------------------- RUNTIME STARTS HERE ----------------------------

# Parse other parameters
case "$1" in
	start)
		shift
		_start "$@"
		;;
	stop)
		_stop
		;;
	cron)
		_cron
		;;
	notify)
		_notify
		;;
	*)
		echo "Usage: $0 start <vhost>|stop"
esac
