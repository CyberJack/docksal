#!/usr/bin/env bash

### Helper functions ###

# Checks if there was any recent container activity (entries in the container logs)
# `docker log` does honor stdout vs stderr outputs. We route everything to stdout to do the comparison (2>&1)
is_container_active ()
{
	container_id="$1"
	[[ "$(docker logs --tail 1 --since $PROJECT_INACTIVITY_TIMEOUT $container_id 2>&1)" != "" ]]
}
is_container_dangling ()
{
	container_id="$1"
	[[ "$(docker logs --tail 1 --since $PROJECT_DANGLING_TIMEOUT $container_id 2>&1)" == "" ]]
}

### Functions ###

# Start containers for a project identified with a virtual host
# @param $1 virtual host name
start ()
{
	# Set logging prefix for the function and trigger a log entry
	export LOG_PREFIX='[start]' && log
	
	local vhost="$1"
	[[ "$vhost" == "" ]] && log "ERROR: Empty virtual host." && return 1

	log "Stoping docker-gen..."
	supervisorctl stop docker-gen

	# Match vhost to a web container (exact match only)
	local project_name
	local container_id
	
	# Filter: web containers, part of a dc project, managed by Docksal
	project_name=$(docker ps -a \
		--filter "label=com.docker.compose.project" \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host=$vhost" \
		--format '{{.Label "com.docker.compose.project"}}')

	# If exact match was not found, then we have multiple domains/wildcards (e.g. example.com,*.example.com,example2.com)
	# More complex processing goes below.
	if [[ "$project_name" == "" ]]; then
		container_id=$(docker ps -a \
			--filter "label=io.docksal.virtual-host=$vhost" \
			--format '{{.ID }}')
		if [[ "$container_id" == "" ]]; then
			# Get a list of all (running and stopped) web containers and their virtual host label values
			local webs=$(docker ps -a \
				--filter "label=io.docksal.virtual-host" \
				--format '{{ .ID }}:{{.Label "com.docker.compose.project"}}:{{.Label "io.docksal.virtual-host"}}')

			# Look for a matching label among all webs
			for web in $webs; do
				# Read variables
				IFS=':' read web_container_id web_project_name web_project_vhost <<< "$web";
				# Split web_project_vhost
				IFS=',' read -a web_project_vhost_arr <<< "$web_project_vhost"
				for i in "${web_project_vhost_arr[@]}"; do
					# Turn domain name into a regular expression (e.g. *.example.com => .*\.example\.com)
					i_reg=$(echo $i | sed "s/\./\\\\./g" | sed "s/\*/\.\*/g")
					# Match vhost using the regular expression we created
					echo "$vhost" | grep "^$i_reg$" >/dev/null
					# Store match and break
					[[ $? -eq 0 ]] && project_name="$web_project_name" && container_id="$web_container_id" && break
				done
				# Break if match was found
				if [[ "$project_name" != "" ]] || [[ "$container_id" != "" ]]; then
					break
				fi
			done
		fi
	fi

	# No match if project_name is empty here.
	if [[ "$project_name" == "" ]]; then
		if [[ "$container_id" == "" ]]; then
			log "ERROR: No matching projects or containers found for virtual host ${vhost}." \
				&& log "Starting docker-gen..." \
				&& supervisorctl start docker-gen \
				&& return 1
		else
			log "Starting single container $container_id..." \
				&& docker start "$container_id" \
				&& log "Starting docker-gen..." \
				&& supervisorctl start docker-gen \
				&& return 0
		fi
	else
		# Connecting/re-connecting vhost-ptoxy to the project network
		local network="${project_name}_default"
		# Making sure the network exists
		docker network create "$network" >/dev/null 2>&1
		# Reconnect vhost-proxy to the project network (in case vhost-proxy has been recently reset)
		docker network connect "$network" docksal-vhost-proxy >/dev/null 2>&1
		if [[ $? == 0 ]]; then
			log "Connected proxy to network: ${network}."
		fi

		log "Starting containers for $project_name..."
		# Dirty hack to avoid using docker-compose and still be able to launch containers with dependencies up to 3 levels deep.
		for i in `seq 1 3`; do
			log "Pass #$i..."
			docker ps -qa --filter "label=com.docker.compose.project=${project_name}" | xargs docker start
		done

		log "Starting docker-gen..."
		supervisorctl start docker-gen
	fi
}

# Stop containers for projects after a timeout set via PROJECT_INACTIVITY_TIMEOUT
stop ()
{
	# Set logging prefix for the function and trigger a log entry
	export LOG_PREFIX='[stop]' && log

	# Allow disabling PROJECT_INACTIVITY_TIMEOUT (0 = disabled)
	[[ "$PROJECT_INACTIVITY_TIMEOUT" == 0 ]] && exit

	# Filter: web containers, part of a dc project, managed by Docksal
	local running_webs=$(docker ps \
		--filter "label=com.docker.compose.project" \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host" \
		--format '{{ .ID }}:{{ .Label "com.docker.compose.project" }}')

	for running_web in $running_webs; do
		# Read variables
		IFS=':' read container_id project_name <<< "$running_web";
		# Skip containers with empty values
		[[ "$project_name" == "" ]] && continue
		# Skip active projects
		is_container_active $container_id && continue

		# Stop inactive project containers
		log "Stopping inactive project: ${project_name}..."
		docker ps -q --filter "label=com.docker.compose.project=${project_name}" | xargs docker stop
		# Disconnect vhost-proxy from the project network and remove the network.
		# See https://github.com/docksal/service-vhost-proxy/issues/6 for more details on why this is necessary.
		local network="${project_name}_default"
		docker network disconnect "$network" docksal-vhost-proxy
		docker network rm "$network"
	done
}

# (Re)connect proxy to project networks.
# Useful when proxy has been just re-provisioned and should be re-connected to existing project networks.
networks ()
{
	# Filter: web containers, part of a dc project, managed by Docksal
	project_names=$(docker ps \
		--filter "label=com.docker.compose.project" \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host" \
		--format '{{.Label "com.docker.compose.project"}}')
	for project_name in $project_names; do
		local network="${project_name}_default"
		# Making sure the network exists
		docker network create "$network" >/dev/null 2>&1
		# Reconnect vhost-proxy to the project network (in case vhost-proxy has been recently reset)
		docker network connect "$network" docksal-vhost-proxy >/dev/null 2>&1
		if [[ $? == 0 ]]; then
			log "Connected proxy to network: ${network}."
		fi
	done
}

cron ()
{
	stats
	stop
}

# Removed projects (containers and sources) after a timeout set via PROJECT_DANGLING_TIMEOUT.
# Projects with the label "io.docksal.permanent=true" are considered permanent and skipped.
cleanup ()
{
	# Set logging prefix for the function and trigger a log entry
	export LOG_PREFIX='[cleanup]' && log

	# Allow disabling PROJECT_DANGLING_TIMEOUT (0 = disabled)
	[[ "$PROJECT_DANGLING_TIMEOUT" == 0 ]] && exit

	# Filter: web containers, part of a dc project, managed by Docksal
	projects=$(docker ps -a \
		--filter "label=com.docker.compose.project" \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host" \
		--format '{{ .ID }}:{{ .Label "com.docker.compose.project" }}:{{ .Label "io.docksal.project-root" }}:{{ .Label "io.docksal.permanent" }}')

	for project in $projects; do
		IFS=':' read container_id project_name project_root permanent <<< "$project"
		# Skip permenent projects
		[[ "$permanent" == "true" ]] && continue
		# Skip active/not dangling projects
		! is_container_dangling $container_id && continue

		# Remove dangling project containers
		log "Removing dangling project: ${project_name}..."
		docker ps -qa --filter "label=com.docker.compose.project=${project_name}" | xargs docker rm -f
		# Disconnect vhost-proxy from the project network and remove the network.
		# See https://github.com/docksal/service-vhost-proxy/issues/6 for more details on why this is necessary.
		local network="${project_name}_default"
		docker network disconnect "$network" docksal-vhost-proxy
		docker network rm "$network"
		# Remove project directory
		# This assumes all projects are kept in the same directory, which is mounted at /projects
		local mounted_project_root="/projects/$(basename $project_root)"
		[[ -d $mounted_project_root ]] && rm -rf $mounted_project_root
	done

	echo "Removing dangling images..."
	docker image prune -f
	echo "Removing dangling volumes..."
	docker volume prune -f
	echo "Removing dangling networks..."
	docker network prune -f
}

# Trigger nginx config reload
notify ()
{
	if [[ "$PROXY_DEBUG" == 1 ]]; then
		cat /etc/nginx/conf.d/default.conf
	fi
	nginx -t && nginx -s reload
}

# Helper for writing log messages
# @param $@ Log message
log ()
{
	echo "$(date +"%F %H:%M:%S") [proxyctl] ${LOG_PREFIX} $@"
}

# Print stats for projects
stats ()
{
	# Set logging prefix for the function and trigger a log entry
	export LOG_PREFIX='[stats]' && log
	
	# Filter: web containers, part of a dc project, managed by Docksal
	projects=$(docker ps -a \
		--filter "label=com.docker.compose.project" \
		--filter "label=com.docker.compose.service=web" \
		--filter "label=io.docksal.virtual-host" \
		--format '{{ .ID }}:{{ .Label "com.docker.compose.project" }}:{{ .RunningFor }}:{{ .Status }}:{{ .Label "io.docksal.permanent" }}')

	# Aggregated stats
	local num_total=0
	local num_running=0
	local num_permanent=0
	local num_active=0
	local num_dangling=0
	
	IFS=$'\n';  # Split projects by newline only (otherwise spaces in the output also trigger a split)
	for project in $projects; do
		IFS=':' read container_id project_name created status permanent <<< "$project"
		
		let "num_total += 1"
		[[ "$status" =~ "Up" ]] && let "num_running += 1"
		if [[ "$permanent" != "true" ]]; then
			permanent='false'
		else
			let "num_permanent += 1"
			permanent='true'
		fi
		if is_container_active $container_id; then
			let "num_active += 1"
			active='true'
		else
			active='false'
		fi
		if is_container_dangling $container_id; then
			let "num_dangling += 1"
			dangling='true'
		else
			dangling='false'
		fi
		
		log "Project: ${project_name} | Created: ${created} | Status: ${status} | Permanent: ${permanent} | Active: ${active} | Dangling: ${dangling}"
	done
	unset IFS

	# Aggregated stats
	log "[summary] Total: ${num_total} | Running: ${num_running} | Permanent: ${num_permanent} | Active: ${num_active} | Dangling: ${num_dangling}"
}

#-------------------------- RUNTIME STARTS HERE ----------------------------

# Parse other parameters
case "$1" in
	start)
		shift
		start "$@"
		;;
	stop)
		stop
		;;
	cron)
		cron
		;;
	notify)
		notify
		;;
	networks)
		networks
		;;
	cleanup)
		cleanup
		;;
	*)
		echo "Usage: $0 start <vhost>|stop|cron|notify|networks|cleanup"
esac
